CORE
- На какие основные группы можно поделить типы данных в Java?
Примитивные / ссылочные



- Какие примитивные типы вы знаете?
8
byte, short, int, long,     float, double,   char, boolean



- Что вы знаете о преобразовании примитивных типов данных, есть ли потеря данных?
Автоматическое расширение из менее вместительных типов в более вместительные.
Но возможна потеря точности при расширении из int/long в float/double.
В иных случаях нужно явно указывать компилятору (cast).



- Какими значениями инициализируются переменные по умолчанию?
Переменные экземпляра - 0, 0.0, false, null.
Локальные переменные - никакими (нужно явно указать их значение, до чтения).



- Как передается значение переменной (по ссылке/значению)?
Всегда по значению (копия).



- Что такое тернарный оператор выбора?
Аналог оператора if-else.



- Какие унарные и бинарные арифметические операции вы знаете?
Унарные: -, +; для целых: ~(инвертирование), ++, -- (префиксные/постфиксные).
Бинарные: +, -, *, /, % (для всех типов). a % b == a - (a / b) * b;



- Какие побитовые операции вы знаете?
&, |, ^, <<, >> (арифметический сдвиг вправо), >>> (логический сдвиг вправо)



- Какова роль и правила написания оператора выбора (switch)?
Оператор выбора (вместо if (i == 1) else if (i == 2)...)
Работает с целыми числами, которые расширяются до int (в т.ч. обертки),
    а также String и enum.
Есть default-ветка и break.



- Какие циклы вы знаете, в чем их отличия?
С предусловием (while)
С постусловием (do-while)
Cо счетчиком (for), усовершенствованный (foreach) для классов,
    имплементирующих java.lang.Iterable



- Какие параметры имеет цикл for, можно ли их не задать?
for (начальная точка; булевское условие; оператор счетчика)
Можно не задавать. Если все не задать - бесконечный цикл.



- Какой оператор используется для немедленной остановки цикла?
break



- Какой оператор используется для перехода к следующей итерации цикла?
continue



- Что такое массив?
Структура данных, в которой хранятся элементы одного типа и доступ к ним
    осуществляется за O(1)



- Что вы знаете о классах оболочках?
Позволяют представить примитивный тип в виде ссылочного.
Возможно использовать значение null.



- Что такое автоупаковка (boxing/unboxing)?
Компилятор преобразует примитивы в соответсвующий тип и наоборот.
При unboxing null - NPE



- Назовите принципы ООП и расскажите о каждом.
Абстракция (выделение наиболее важных характеристик)
Инкапсуляция (сокрытие данных реализации и доступ к ним с помощью сеттеров)
Наследование (использование существующих классов для создания новых)
Полиморфизм (использование контракта базового класса без информации о
    конкретном типе экземпляра)



- Дайте определение понятию “класс”.
Шаблон, который определяет состояние и функции экземпляра



- Что такое поле/атрибут класса?
Это переменная экземпляра, т.е. та, которая доступна во всем классе.
Инициализируется значениями по умолчанию, хранится в heap,
    в отличие от локальных переменных.



- Как правильно организовать доступ к полям класса?
Модификатор private + геттер/сеттер.



- Дайте определение понятию “конструктор”.
Блок кода, который возможно использовать только с ключевым словом new.
Запускается до возможности использовать экземпляр класса.



- Чем отличаются конструктор по-умолчанию и конструктор с параметрами?
Если явно не написаны конструкторы, компилятор подставит конструктор
    по-умолчанию с модификатором доступа, который объявлен у класса.
С помощью конструктора с параметрами возможно инициализировать
    переменные экземпляра, которые необходимы для работы с экземпляром.
    (Возможно присвоить значения финальным полям).



- Какие модификаторы доступа вы знаете, расскажите про каждый из них.
private - доступ только внутри класса
default-package - доступ внутри пакета
protected - доступ внутри пакета + наследники
public - везде



- О чем говорят ключевые слова “this”, “super”, где и как их можно использовать?
this - экземпляр данного класса
super - экземпляр суперкласса
При связывании конструкторов (this(), super()),
    при переопределении методов/обращ (super.m(), this.m())



- Дайте определение понятию “метод”.
Алгоритм решения определенной задачи. Аналог функции из процедурных ЯП.



- Что такое сигнатура метода?

имя + список параметров (порядок имеет значение)
    (возвращаемый тип, исключения не входит)



- Какие методы называются перегруженными?
Одно и то же имя, но разные списки параметров.



- Могут ли нестатические методы перегрузить статические?
Да. Статический будет принадлежать классу,
    нестатический - экземпляру класса.



- Расскажите про переопределение методов.
Замещение (overriding) метода суперкласса у сабкласса
    (возвращаемый тип, сигнатура, исключения (или их нет) те же)



- Может ли метод принимать разное количество параметров (аргументы переменной длины)?
Да. Varargs. Указывается последним в списке параметров, может быть только один.
Представляется компилятором как массив.
Могут случаться непредвиденные ошибки (m(int i) vs m(int... i))



- Чем отличается переопределение от перегрузки?
Перегрузка - создается новый метод со старым именем;
    метод выбирается при компиляции
Переопределение - существующий метод изменяет свое поведение;
    метод выбирается в рантайм (виртуальный метод)



- Зачем нужен оператор instanceof?
Для проверки, принадлежит ли экзмепляр определенному классу
    (мб наследник)
Но принято использовать дженерики



- Зачем нужны и какие бывают блоки инициализации?
Статический блок инициализации (static {})
Динамический блок инициализации ({})



- Каков порядок вызова конструкторов и блоков инициализации двух классов: потомка и его предка?
Статические элементы суперкласса
    (Статические поля родителя -> статические блоки инициализации родителя)
Статические элементы сабкласса

Поля суперкласса
Поля подкласса

Конструктор суперкласса
Конструктор подкласса



- Где и для чего используется модификатор abstract?
Для классов/методов



- Можно ли объявить метод абстрактным и статическим одновременно?
Нет (противоречие:
    абстрактный - реализация в потомке
    статический - реализация в данном классе)



- Что означает ключевое слово static?
Метод/класс/переменная принадлежит классу (не экземлпяру)



- К каким конструкциям Java применим модификатор static?
Переменная/инициализатор/метод/вложенный класс



- Можно ли перегрузить static метод?
Да (но нельзя переопределить - будут просто с одинаковой сигнатурой в каждом классе)



- Что такое статический класс, какие особенности его использования?
Только вложенный. Имеет доступ только к статическим переменным/методам
    обрамляющего класса.
Обращение через имя обрамляющего класса + вложенного



- Как влияет модификатор static на класс/метод/поле?
Принадлежит классу. Определяется еще до конструктора.
    Доступ только к статическим членам.



- О чем говорит ключевое слово final?
Невозможно унаследоваться/переопределить/присвоить новое значение.



- Дайте определение понятию “интерфейс”.
Шаблон, который задает контракт и не имеет реализации.
Позволяют имплементировать больше одного (в отличие от одного класса).
Внутри - константы.
Не имеют конструкторов.



- Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
Поля: public static final ...
Методы: public abstract



- Какие особенности создания вложенных классов: простых и статических.
nested non-static class (inner) - связан с обрамляющим классом
    (имеют доступ к приватным не-статическим внешнего)
    Ассоциируется не с самим классом, а с экземпляром внешнего класса.
    Не может содержить статических членов.
nested static class - не связан
    (имеют доступ к приватным статическим внешнего)



- Что вы знаете о вложенных классах, зачем они используются? Классификация, варианты использования, о нарушении инкапсуляции.
Вложенные классы: статические / не-статические.
Нарушение инкапсуляции заключается в том, что вложенный класс может
    обращаться к приватным полям обрамляющего класса.
    Если nested static class - к private static
    Если inner class - к private



- В чем разница вложенных и внутренних классов?
Вложенные классы - все, среди которых внутренние - не статические.
Внутренний класс не может содержать статики и enum.



- Какие классы называются анонимными?
Локальный класс без имени (внутри нет статики, кроме констант).
Может реализовать что-то только одно.



- Каким образом из вложенного класса получить доступ к полю внешнего класса?
Если вложенный - статический, то только к статическим внешнего
    (либо через ссылку на внешний к не-статическим)
Если внутренний - ко всему.



- Каким образом можно обратиться к локальной переменной метода из анонимного класса,
            объявленного в теле этого метода?
            Есть ли какие-нибудь ограничения для такой переменной?
Локальные переменный должны быть либо эффективно-финальными, либо финальными.



- Как связан любой пользовательский класс с классом Object?
В Java все наследуется от java.lang.Object (неявно extends java.lang.Object)



- Расскажите про каждый из методов класса Object.
public String toString() - представление экземляра в виде строки
public boolean equals(Object o) - определение равенства двух экземпляров
public native int hashCode() - представление экземпляра в виде хеш-кода

public final native Class<?> getClass() - возвращает объект типа Class<?> для данного класса

public final void wait() / void wait(long ms) - в синхронизованном блоке
    заставляет данный поток отпустить монитор объекта и ожидать, пока данный поток
    не пробудят (interrupt/notify/notifyAll/истечет время ms)

public final native void notify() - в синхронизованном блоке
    jvm будит любой поток, ожидающий на данном мониторе
public final native void notifyAll() - в синхронизованном блоке
    jvm будет все потоки, ожидающие на данном мониторе

protected native Object clone() - возвращает копию объекта (необходимо
    имплементировать маркерный интерфейс java.lang.Cloneable)

protected void finalize() - deprecated, вызывается JVM перед тем,
    как объект будет удален из heap (когда нет активных ссылок на объект)



- Что такое метод equals(). Чем он отличается от операции ==.
В примитивах == сравнивает значения, в ссылочных типах,
    саму ссылку (размером 4/8 байт)
Дефолтная реализация equals(): ==
Переопределенная должна сравнивать значения полей



- Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?
Рефлексивность: a == a
Симметричность: a == b, b == a
Транзитивность: a == b, b == c, a == c
Консистентность: множественные вызовы equals() должны возвращать одно и то же значение

- Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?
Также и public native int hashCode() - для хранения в Hash... коллекциях

- В чем особенность работы методов hashCode и equals?
        Каким образом реализованы методы hashCode и equals в классе Object?
        Какие правила и соглашения существуют для реализации этих методов?
        Когда они применяются?
hashCode() и equals() должны быть согласованны:
    если equals() возвращает true, то hashCode() должен вернуть одинаковые значения
    (наоборот не обязательно)
Дефолтная реализация:
hashCode() - алгоритм Park-Miller RNG (генератор случайных чисел).
    При каждом создании объекта будем получать разные значения.



- Какой метод возвращает строковое представление объекта?
toString()



- Что будет, если переопределить equals не переопределяя hashCode?
        Какие могут возникнуть проблемы?
Проблемы с хранением объектов в Hash... коллекциях
    (т.к. сначала вызывается hashCode(), затем equals())



- Есть ли какие-либо рекомендации о том, какие поля следует использовать при
        подсчете hashCode?
Использовать поля, который вероятнее всего будут различаться (id).
Лучше примитивы.
Их также задействовать и в equals.
Чтобы уменьшить количество коллизий.



- Как вы думаете, будут ли какие-то проблемы, если у объекта,
        который используется в качестве ключа в hashMap изменится поле,
        которое участвует в определении hashCode?
Да, возникнут проблемы с поиском объекта, так как изменится хеш-код объекта.
(А сама хеш-таблица не перестроится)
Лучше использовать immutable-классы.



- Чем отличается абстрактный класс от интерфейса,
        в каких случаях что вы будете использовать?
Абстрактный класс имеет конструктор, в отличие от интерфейса.
Наследование от абстрактного класса - "IS-A" (Animal),
    интерфейс может быть реализован в классах, не связанных
    (похоже на качество, присущее классу (AbleToEat))
Возможно реализовывать множество интерфейсов (но не классов)



- Можно ли получить доступ к private переменным класса и если да,
    то каким образом?
С помощью рефлексии (getDeclaredFields() -> setAccessible())



- Что такое volatile и transient?
    Для чего и в каких случаях можно было бы использовать default?
volatile - значение переменной не хранится в кэшах потоков
    (всегда обращение к одной).
    Удобно использовать, если ОДИН поток
    изменяет, другие читают&
transient - для переменных экземпляра, которые не подлежат сериализации
    (приватные данные, те которые можно посчитать на основе других)
default - метод в интерфейсе с реализацией (можно переопределить)
        - ветка в switch (можно выбросить исключение)


- Имеет ли смысл объявлять метод private final?
private методы и так недоступны в наследниках, это избытычно



- Какие особенности инициализации final переменных?
final переменная может быть инициализирована только один раз,
    можно через if-else позже присвоить ей значение,
    но внутреннее состояние объектов можно изменить



- Что будет, если единственный конструктор класса объявлен как final?
Конструктор не может иметь модификатор final



- Что такое finalize? Зачем он нужен?
        Что Вы можете рассказать о сборщике мусора и алгоритмах его работы.
    Вызывается JVM перед тем, как объект будет удален из кучи.
    Позволяет подчистить ресурсы, захваченные объектом во время его работы
        (это как последний шанс освободить ресурсы).
    Deprecated since Java 9.




- Почему метод clone объявлен как protected? Что необходимо для реализации клонирования?
Чтобы разработчики классов могли сами решить, нужен ли им механизм копирования
    без вызова конструкторов (native метод). Необходимо имплементировать
    маркерный интерфейс Cloneable.
    Но здесь происходит поверхностное копирование (shallow) - внтури объекта
    ссылки будут скопированы, но не сами объекты.
    Лучше использовать механизм сериализации (объект представляется потоком байтов).



- Можно ли наследовать строковый тип, почему?
Нет. Строки используются везде (базы данных, многопоточные среды и пр.).
Для безопасности класс финальный.



- Дайте определение понятию конкатенация строк.
    Операция объединения двух строк с возвращением новой.
    Для каждого "+" компилятор вызывает конструктор StringBuilder(),
        его метод append(), затем toString()



- Как преобразовать строку в число?
У каждой обертки есть метод valueOf(String)



- Как сравнить значение двух строк?
equals() либо
    создать две строки с помощью вызова конструктора String,
    к каждому вызову применить intern()
    и сравнить на == (быстрее будет, если строки длинные)



- Как перевернуть строку?
new StringBuilder(String).reverse()



- Как работает сравнение двух строк?
== ссылки
equals() переопределен в String и сравнивает хранящиеся байты внутри объекта



- Чем отличаются и что общего у классов String, StringBuffer и StringBuilder?
String - immutable класс для представления строкового типа
StringBuilder - mutable класс для представления строкового типа
StringBuffer - mutable синхронизованный класс



- Как сделать утечку памяти?
В куче есть объекты, которые GC не может удалить.
<- в цикле добавлять в StringBuilder
<- статические поля (лист) - до конца работы программы
<- внутренний класс - хранит ссылку на внешний (лучше nested static class)
<- не переопределенные equals, hashcode у ключа в map - всегда новая пара
<- незакрытые ресурсы